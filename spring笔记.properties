1.Spring源码系列之容器启动流程
    参考链接：.https://juejin.cn/post/6993313671791247368
    参考类：
        org.springframework.orm.MyApplication
    1.this调用：初始化DefaultListableBeanFactory
    2.register方法：
    3.refresh方法（核心）
2.spring源码系列----循环依赖源码分析：（写的超好，推荐）
    通过三级缓存来解决循环依赖的
        https://juejin.cn/post/6997209721232949255
    注意：
        1.正常普通的bean是放在三级缓存中
        2. 循环依赖的对象只能在一级二级缓存中取

            缓存单例bean到三级缓存中, 以防止循环依赖
            判断是否是早期引用的bean, 如果是, 则允许提前暴露引用

        问题：
            1. 为什么需要二级缓存和三级缓存？
            2.有没有解决构造函数的循环依赖
            3.有没有解决多例下的循环依赖
3.Spring 解决循环依赖必须要三级缓存吗？(超级好)
    解决循环依赖的核心是提前暴露对象
    https://juejin.cn/post/6882266649509298189
4。spring boot学习之用户class文件扫描总结
    https://blog.csdn.net/weixin_44181697/article/details/98526044
    参考方法：
        org.springframework.context.annotation.ComponentScanAnnotationParser.parse
5.spring的注解：@Scope
    https://juejin.cn/post/6868913998961197064
    注意：
        当一个单例的 Bean，使用 autowired 注解标记其属性时，你一定要注意这个属性值会被固定下来。
6.显式引用 Bean 时首字母忽略大小写
    如果连续两个都是大写，会选择大写
7.@value的三大步骤：
    1.寻找 @Value
    2.解析 @Value 的字符串值
    3.将解析结果转化为要装配的对象的类型
    参考：
        org.springframework.beans.factory.support.DefaultListableBeanFactory.doResolveDependency
8.默认构造器中引用依赖类，抛空指针异常
    原因：
        使用 @Autowired 直接标记在成员属性上而引发的装配行为是发生在构造器执行之后的
    解决方案：
        1.创建一个有参构造器，把依赖类作为参数传进去
        2.添加 init 方法，并且使用 PostConstruct 注解进行修饰：
        3.实现 InitializingBean 接口，在其 afterPropertiesSet() 方法中执行初始化代码：